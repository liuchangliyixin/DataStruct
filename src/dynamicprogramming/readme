动态规划
    硬币找零问题
        问题：
            给定 n 种不同面值的硬币，分别记为 c[0], c[1], c[2], … c[n]，同时还有一个总金额 k，
            编写一个函数计算出最少需要几枚硬币凑出这个金额 k？每种硬币的个数不限，且如果没有任何一种硬币组合能组成总金额时，返回 -1。
            示例：从c[0]=5, c[1]=3 且 k=11 的情况下寻求最少硬币数。---编程求解：MinCoinCount.java
            
            这是一个求最值的问题。那么求最值的核心问题是什么呢？
            就是穷举，显然，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币，那么最少的凑法，就是这道题目的答案。
            一般来说穷举从来都不是一个好方法。除非你要的结果就是所有的不同组合，而不是一个最值。
            但即便是求所有的不同组合，在计算的过程中也仍然会出现重复计算的问题，称之为重叠子问题。

    贪心算法
        所谓贪心算法，就是指它的每一步计算作出的都是在当前看起来最好的选择，也就是说它所作出的选择只是在某种意义上的局部最优选择，
        并不从整体最优考虑。在这里，我把这两种选择的思路称作局部最优解和整体最优解。

        贪心算法的基本思路：
            根据问题来建立数学模型；
            把待求解问题划分成若干个子问题，对每个子问题进行求解，得到子问题的局部最优解；
            把子问题的局部最优解进行合并，得到最后基于局部最优解的一个解，即原问题的答案。

        虽然纯粹的贪心算法作用有限，但是这种求解局部最优的思路在方向上肯定是对的，毕竟所谓的整体最优肯定是从很多个局部最优中选择出来的，
        因此所有最优化问题的基础都是贪心算法。

        所有贪心的思路就是我们最优化求解的根本思想，所有的方法只不过是针对贪心思路的改进和优化而已。
        回溯解决的是正确性问题，而动态规划则是解决时间复杂度的问题。贪心算法是求解整体最优的真正思路源头。

        回溯的思想在硬币找零这个问题里，具体说就是如果遇到已经无法求解的组合，那么我们就往回退一步，修改上一个面值的硬币数量，然后再尝试新的组合。

        递归这种形式，正是赋予了回溯这种可以回退一步的能力：它通过堆栈保存了上一步的当前状态。
        因此，如果想要用回溯的策略来解决问题，那么递归应该是你的首选方法。

        虽然递归在数学意义上非常直观，但是如果问题过于复杂，就很难继续在脑海中模拟出整个求解过程了。
        因此，一旦程序出现 bug，当你想尝试去调试的时候，就会发现这样的代码几乎没有调试的可能性。

    优化暴力递归：剪枝
        仿照贪心算法，从整个搜索策略上来调整。
            也就是说，你要考虑这个问题的性质，在硬币找零问题中面值大的硬币用得足够多，那么这个组合的硬币总数肯定就最小。
            所以在每一次递归时，我们不应该暴力地搜索所有的面值，而应该从面值最大的硬币着手，不断尝试大面值硬币的最大情况。
            如果无法满足条件再减少一个，再递归搜索。通过贪心这种思路结合递归实现一种组合搜索。
        从解空间图解释
            在这个硬币求解问题中，当余额相同的时候，最优解是确定的。那么如果能够避免相同余额下的重复搜索过程，那么算法执行速度是不是可以加快了？
            这就是重叠子问题。
            可以把求解 12 元的硬币数量理解成求解 25 元的硬币数量的一个子问题。在求解 25 元硬币过程中，会有很多种情况都要求解 12 元硬币的最优解。
            显然，这就是我们可以优化的出发点。

    重叠子问题
        递归中的备忘录：解决重复计算的法宝
        亟待解决的问题：消除重叠子问题，即消灭重复计算的过程。
        可以创建一个备忘录（memorization），在每次计算出某个子问题的答案后，将这个临时的中间结果记录到备忘录里，然后再返回。
        接着，每当遇到一个子问题时，我们不是按照原有的思路开始对子问题进行递归求解，而是先去这个备忘录中查询一下。
        如果发现之前已经解决过这个子问题了，那么就直接把答案取出来复用，没有必要再递归下去耗时的计算了。

        对于备忘录，你可以考虑使用以下两种数据结构：
            数组（Array），通常对于简单的问题来说，使用一维数组就足够了。
            哈希表（Hash table），如果存储的状态不能直接通过索引找到需要的值，可以考虑使用哈希表，即字典来存储中间状态，来避免重复计算的问题。

        重叠子问题缓存的限制
            比如八皇后问题。既然没有重叠子问题，那么通过通过备忘录来对其优化加速，又从何谈起呢？
            有些问题虽然看起来像包含“重叠子问题”的子问题，但是这类子问题可能具有后效性，但我们追求的是无后效性。
            所谓无后效性，指的是在通过 A 阶段的子问题推导 B 阶段的子问题的时候，我们不需要回过头去再根据 B 阶段的子问题重新推导 A 阶段的子问题，
            即子问题之间的依赖是单向性的。